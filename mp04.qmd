---
title: "MP04"
author:
  - name: Clinta Puthussery Varghese
  
format:
  pdf: 
    code-fold: true
    toc: true
---
Data Collection
```{r}
#| warning: false
#| message: false

if(!require("httr")) install.packages("httr")
if(!require("jsonlite")) install.packages("jsonlite")
if(!require("tidyverse")) install.packages("tidyverse")
if(!require("ggplot2")) install.packages("ggplot2")
if(!require("plotly")) install.packages("plotly")

library(plotly)
library(ggplot2)
library(httr2)
library(jsonlite)
library(tidyverse)
```

```{r}
#| warning: false
#| message: false
# Load environment variables
readRenviron("~/STA9750-2024-FALL/MP-DATA/.Renviron")
# Load environment variables
#source("~/STA9750-2024-FALL/functions_MP04.R")
```
Functions to fetch from AlphaVantage and FRED
```{r}
#| warning: false
#| message: false
convert_fred_datatype=function(fred_data){
  fred_data=fred_data|>
    mutate(date=as.Date(date),value=as.numeric(value))|>
    group_by(date)|>
    summarise(value = mean(value, na.rm = TRUE), .groups = "drop")
  return(fred_data)
}
calculate_return_symbol <- function(alpha_vantage_symbol_data) {
  # Dynamically construct the name for the returns column
  return_column_name <- paste0(unique(alpha_vantage_symbol_data$symbol), "_returns")}

# Define variables

convert_to_a_table<-function(symbol_data)
{ do.call(
  rbind, 
  lapply(
    names(symbol_data$`Monthly Adjusted Time Series`), 
    function(date) {
      # Extract the record for the given date
      record <- symbol_data$`Monthly Adjusted Time Series`[[date]]
      
      # Check if all required fields are present
      if (!is.null(record$`1. open`) && 
          !is.null(record$`2. high`) && 
          !is.null(record$`3. low`) && 
          !is.null(record$`4. close`) && 
          !is.null(record$`6. volume`) && 
          !is.null(record$`7. dividend amount`)) {
        
        # Create a data frame for non-missing records
        return( data=data.frame(
          date = as.Date(date),                      # Convert date string to Date
          open = as.numeric(record$`1. open`),
          high = as.numeric(record$`2. high`),
          low = as.numeric(record$`3. low`),
          close = as.numeric(record$`4. close`),
          adjusted_close = as.numeric(record$`5. adjusted close`),
          volume = as.numeric(record$`6. volume`),
          dividend = as.numeric(record$`7. dividend amount`),
          stringsAsFactors = FALSE
        ))
      } else {
        # Skip records with missing fields
        return(NULL)
      }
    }
  )
)
}

fetch_alpha_vantage <- function(symbol, function_name = "TIME_SERIES_MONTHLY_ADJUSTED") {
  av_key <- Sys.getenv("AV_KEY")
  url <- paste0(
    "https://www.alphavantage.co/query?",
    "function=", function_name,
    "&symbol=", symbol,
    "&apikey=", av_key
  )
  
  # Make the API request
  response <- GET(url)
  
  if(status_code(response)==200){
    # Parse and print the JSON data
    data <- content(response, as = "parsed")
    data_table<-data|>convert_to_a_table()
    data_table=data_table|>mutate(month=floor_date(as.Date(date), "month"))|>group_by(month) |>
            summarize(adjusted_close = last(adjusted_close))
    return(data_table)
  }
  else
  {
    stop("failed to fetch data")
  }
}


# Function to fetch data from FRED
fetch_fred <- function(series_id) {
  fred_key <- Sys.getenv("FRED_KEY")
  real_time_start="1980-01-01"
  real_time_end=Sys.Date()
  frequency="m"
  url2 <- paste0("https://api.stlouisfed.org/fred/series/observations?",
                 "series_id=",series_id,
                 "&realtime_start=",real_time_start,
                   "&realtime_end=",real_time_end,
                 "&frequency",frequency,
                 "&api_key=",fred_key,
                 "&file_type=json")
  response_t=GET(url2)
  
  
  # Check response status
  if (status_code(response_t) == 200) {
    content<-content(response_t)
    my_list<-content$observations|>as.list()
    my_table <- do.call(rbind, lapply(my_list, function(x) {
      data.frame(
        realtime_start = x$realtime_start,
        realtime_end   = x$realtime_end,
        date           = x$date,
        value          = x$value,
        stringsAsFactors = FALSE
      )
    }))
  
   
  } else {
    stop("Failed to fetch data from FRED.")
  }
}

```

Data Collection
Rate of Inflation:yes
Rate of Wage Growth:
US Equity Market Returns:alpha
International Equity Market Returns:
Bond Returns:
Short Term Debt Returns:
1.Inflation Data
```{r}
library(lubridate)

#| warning: false
#| message: false

# Inflation, consumer prices for the United States 
INFLATION_ANNUAL=fetch_fred(series_id = "FPCPITOTLZGUSA")|>convert_fred_datatype()|>mutate(Annual_CPI_Percentage=value)

#Consumer Price Index for All Urban Consumers: All Items in U.S. City Average (CPIAUCSL)
INFLATION_US_URBAN_AVERAGE=fetch_fred(series_id = "CPIAUCSL")|>convert_fred_datatype()|>rename(US_City_Monthly_Inflation_Average=value,month=date)

annual_inflation_average_percentage<-INFLATION_US_URBAN_AVERAGE |>
  mutate(year = year(month)) |>
  group_by(year) |>
  summarize(
    annual_inflation_average = mean(US_City_Monthly_Inflation_Average), # Annual average
    .groups = "drop"                       # Ungroup after summarizing
  ) |>
  mutate(
    perc_change_annual = (annual_inflation_average - lag(annual_inflation_average)) / lag(annual_inflation_average)*100
  )
                                                                                                                                                                      
# Consumer Price Index for All Urban Consumers: All Items in New York-Newark-Jersey City, NY-NJ-PA (CBSA)
INFLATION_NYC=fetch_fred(series_id ="CUURA101SA0")|>convert_fred_datatype()|>mutate(type="NYC Monthly Average ")


```
2.Wage Growth
```{r}
#| warning: false
#| message: false
WAGE_GROWTH_DATA<-fetch_fred("CES0500000003")|>convert_fred_datatype()|>rename(wage_growth_rate=value,month=date)
WAGE_GROWTH_GOVT_EMPLOYEES<-fetch_fred("CIU3026100000000I")|>convert_fred_datatype()|>rename(wage_growth_rate=value,month=date)
```

##function to find the returns:
```{r}
#| warning: false
#| message: false
calculate_return_symbol <- function(alpha_vantage_symbol_data) {
  # Dynamically construct the name for the returns column
  # Dynamically construct the name for the returns column
  return_column_name <- paste0(unique(alpha_vantage_symbol_data$symbol), "_returns(%)")
  ret_vect<-alpha_vantage_symbol_data|>mutate(value=(adjusted_close/lag(adjusted_close)-1)*100,value=round(value,2))|>
    rename(!!return_column_name := value)
  return(ret_vect)
}
 
```
# function to calculate long run average:
```{r}
#| warning: false
#| message: false

long_run_monthly_avg <- function(returns_df){
  return_column_name <- paste0(unique(returns_df$symbol), "_returns(%)")
  rect_df<-returns_df |>
  mutate(month_only = format(month, "%m")) |>  # Extract month (e.g., "01" for January)
  group_by(month_only) |>                     # Group by month
  summarise(
    monthly_avg_return = mean(.data[[return_column_name]], na.rm = TRUE) # Calculate the average
  )
  return(rect_df)
}
```

3.US Equity Markets Returns:

```{r}
#| warning: false
#| message: false
 #S&P 500 ETF as a proxy for US equity market
SPY_ETF <- fetch_alpha_vantage(symbol = "SPY")
SPY_ETF$symbol="SPY"
QQQ_ETF <- fetch_alpha_vantage(symbol = "QQQ")
QQQ_ETF$symbol="QQQ"
DIA_ETF <- fetch_alpha_vantage(symbol = "DIA")
DIA_ETF$symbol="DIA"

usequity1.perc.returns=calculate_return_symbol(SPY_ETF)
usequity2.perc.returns=calculate_return_symbol(QQQ_ETF)
usequity3.perc.returns=calculate_return_symbol(DIA_ETF)
usequity.all.perc.returns=list(usequity1.perc.returns|>select(month,`SPY_returns(%)`),usequity2.perc.returns|>select(month,`QQQ_returns(%)`),usequity3.perc.returns|>select(month,`DIA_returns(%)`))|>
  reduce(full_join, by = "month") |>
  arrange(month) |>
  drop_na() |>mutate(
    US_equity_market_return = rowMeans(across(c(`SPY_returns(%)`, `QQQ_returns(%)`, `DIA_returns(%)`)), na.rm = TRUE)
  )


```
4. International Equity Returns:
```{r}
#| warning: false
#| message: false
VTMGX_INT<-fetch_alpha_vantage(symbol="VTMGX")|>mutate(symbol="VTMGX")
VEIEX_INT<-fetch_alpha_vantage(symbol="VEIEX")|>mutate(symbol="VEIEX")
int1.perc.returns=calculate_return_symbol(VTMGX_INT)
int2.perc.returns=calculate_return_symbol(VEIEX_INT)
int.all.perc.returns=list(int1.perc.returns|>select(month,`VTMGX_returns(%)`),int2.perc.returns|>select(month,`VEIEX_returns(%)`))|>
  reduce(full_join, by = "month") |>
  arrange(month) |>
  drop_na() |>mutate(
    Int_equity_market_return = rowMeans(across(c(`VTMGX_returns(%)`, `VEIEX_returns(%)`)), na.rm = TRUE)
  )
```

5.Bonds
```{r}
#| warning: false
#| message: false
AGG_BONDS<-fetch_alpha_vantage(symbol="AGG")|>mutate(symbol="AGG")
VICSX_BONDS<-fetch_alpha_vantage(symbol="VICSX")|>mutate(symbol="VICSX")
bond1.perc.returns=calculate_return_symbol(AGG_BONDS)
bond2.perc.returns=calculate_return_symbol(VICSX_BONDS)
bonds.all.perc.returns=list(bond1.perc.returns|>select(month,`AGG_returns(%)`),bond2.perc.returns|>select(month,`VICSX_returns(%)`))|>
  reduce(full_join, by = "month") |>
  arrange(month) |>
  drop_na() |>mutate(
    Bonds_equity_market_return = rowMeans(across(c(`AGG_returns(%)`, `VICSX_returns(%)`)), na.rm = TRUE)
  )
```

6.Short term
```{r}
#| warning: false
#| message: false
VSGDX_SHORT_TERM<-fetch_alpha_vantage(symbol="VSGDX")|>mutate(symbol="VSGDX")
short.term.perc.returns=calculate_return_symbol(VSGDX_SHORT_TERM)
#short.term.long.run.monthly.returns
#long_run_monthly_avg(short.term.perc.returns)
```

```{r}
#| warning: false
#| message: false
 all.data=list(WAGE_GROWTH_DATA,INFLATION_US_URBAN_AVERAGE|>select(month,US_City_Monthly_Inflation_Average),usequity.all.perc.returns|>select(month,US_equity_market_return),int.all.perc.returns|>select(month,Int_equity_market_return),bonds.all.perc.returns|>select(month,Bonds_equity_market_return),short.term.perc.returns|>select(month,`VSGDX_returns(%)`))|>
  reduce(full_join, by = "month")|>
  arrange(month) |>
  drop_na() 
```

```{r}
#| warning: false
#| message: false
inflation_us_urban_average=INFLATION_US_URBAN_AVERAGE|>rename(value=US_City_Monthly_Inflation_Average,date=month)|>mutate(type="US_City_Monthly_Inflation_Average")
INFLATION_ALL=rbind(inflation_us_urban_average,INFLATION_NYC)
ggplot (data = INFLATION_ALL|>filter(year(date)>=1990), aes(x=date, y=value,color=type))+
  geom_line(linewidth=0.75)+
  theme_light()+
  labs (title="Comparing the Inflation in NYC and US Cities Average (1990-2024)",
        y="Index 1982-1984=100, Not Seasonally Adjusted",
        x= "year",
        caption = "FRED IDs: CPIAUCSL & CUURA101SA0")+
  theme(text= element_text(family="serif"),
        plot.title = element_text(size=12, face="bold"),
        axis.title = element_text(size=8, face="italic"),
        plot.caption = element_text(size=6, face="italic"),
        plot.title.position = "plot")
```

```{r}
#| warning: false
#| message: false
US_MARKET_EQUITY=rbind(SPY_ETF,QQQ_ETF,DIA_ETF)

gg<-ggplot(US_MARKET_EQUITY, aes(x = month, y = adjusted_close, color = symbol, group = symbol)) +
  geom_line(size = 1.2)  +
  labs(
    title = "Montly Adjusted Close Prices of SPY, QQQ, and DIA (US MARKET EQUITY)",
    x = "Date",
    y = "Adjusted Close Price"
  ) +
  theme_bw()
ggplotly(gg)
```

```{r}
#| warning: false
#| message: false
INTERNATIONAL_MARKET_EQUITY=rbind(VTMGX_INT,VEIEX_INT)

gg2<-ggplot(INTERNATIONAL_MARKET_EQUITY, aes(x = month, y = adjusted_close, color = symbol, group = symbol)) +
  geom_line(size = 1.2)  +
  labs(
    title = "Montly Adjusted Close Prices of VTMGX,VEIEX(INTERNATIONAL_EQUITY)",
    x = "Date",
    y = "Adjusted Close Price"
  ) +
  theme_bw()
ggplotly(gg2)
```

```{r}
#| warning: false
#| message: false
BOND_MARKET_EQUITY=rbind(AGG_BONDS,VICSX_BONDS)

gg3<-ggplot(BOND_MARKET_EQUITY, aes(x = month, y = adjusted_close, color = symbol, group = symbol)) +
  geom_line(size = 1.2)  +
  labs(
    title = "Montly Adjusted Close Prices of AGG and VICSX(BOND MARKET EQUITY)",
    x = "Date",
    y = "Adjusted Close Price"
  ) +
  theme_bw()
ggplotly(gg3)
```

```{r}
#| warning: false
#| message: false
ALL.DATA=rbind(BOND_MARKET_EQUITY|>mutate(type="BONDS"),INTERNATIONAL_MARKET_EQUITY|>mutate(type="INTERNATIONAL"),US_MARKET_EQUITY|>mutate(type="US MARKET"))

gg4<-ggplot(ALL.DATA, aes(x = month, y = log10(adjusted_close), color = type, group = symbol)) +
  geom_line(size = 1.2)  +
  labs(
    title = "Log10 Monthly Adjusted Close Prices for Bond, International, and US Market Equities",
    x = "Date",
    y = "Log10 Adjusted Close Price"
  ) +
  theme_bw()
ggplotly(gg4)
```

The Bonds Market Equity line exhibits smoother, more stable growth compared to the others, reflecting the generally lower volatility in bond markets. US Market Equity show greater volatility and fluctuation, characteristic of stock market performance, where prices tend to experience sharper rises and declines. International Market Equity provides insights into global economic trends, potentially reflecting periods of growth or decline in different countries or regions. The log10 transformation allows for a more uniform view of percentage changes, making the comparison of relative growth rates more apparent than comparing raw values.

```{r}
#| warning: false
#| message: false
calculate.return=function(alpha_vantage_symbol_data){
  ret_vect<-alpha_vantage_symbol_data$adjusted_close/lag(alpha_vantage_symbol_data$adjusted_close)-1
  return(ret_vect)
}
calculate_monthly_average_return=function(alpha_vantage_symbol_data){
  ret_df=alpha_vantage_symbol_data|>group_by(month)|>
    summarize(average_monthly_return=round(mean(returns,na.rm=TRUE),3),
              `average_monthly_return_(%)`=average_monthly_return*100)|>na.omit()|>  # Remove NA values for better plotting
    mutate(direction = ifelse(`average_monthly_return_(%)` >= 0, "Increasing", "Decreasing"),
           year = year(month), 
           month = as.Date(paste0(month, "-01")))
  return(ret_df)
}
calculate_annual_average_return=function(average_return_data){
  rect_df<-average_return_data %>%
    group_by(year) %>%
    summarise(`annual_return_(%)` = round((prod(1 + average_monthly_return, na.rm = TRUE)^(1 / 12) - 1),5)*100)
  return(rect_df)
}
US_MARKET_EQUITY_RETURNS<-US_MARKET_EQUITY |>
  group_by(symbol) |>
  mutate(returns = calculate.return(cur_data()))|>calculate_monthly_average_return()
US_MARKET_EQUITY_RETURNS<-US_MARKET_EQUITY |>
  group_by(symbol) |>
  mutate(returns = calculate.return(cur_data()))|>calculate_monthly_average_return()

# Calculate the geometric average annual return (you can choose simple)
annual_return <-US_MARKET_EQUITY_RETURNS|>calculate_annual_average_return()

# Merge monthly returns with the annual returns
US_MARKET_EQUITY_RETURNS <- left_join(US_MARKET_EQUITY_RETURNS, annual_return, by=c( "year"="year"))

ggg<-ggplot(US_MARKET_EQUITY_RETURNS, aes(x = month, y = `average_monthly_return_(%)`)) +
  geom_col(aes(fill = direction), size = 1.2) +  # Monthly returns as bars
  geom_line(aes(x=month,y =`annual_return_(%)` , color = "Annual Return %"), size = 1.5) +  # Annual return as a line
  scale_fill_manual(values = c("Increasing" = "green", "Decreasing" = "red")) +
  scale_color_manual(values = c("Annual Return %" = "blue")) +  # Color for the annual return line
  labs(
    title = "Equal-Weighted U.S. Market Equity Monthly and Annual Returns (SPY, QQQ, DIA)",
    x = "Month",
    y = "Return (%)",
    fill = "Monthly Return Direction",
    ) +
  scale_x_date(date_labels = "%b %Y", date_breaks = "6 months" )+  # Format x-axis as months
  theme_minimal(base_size = 10) +  # Larger font size for better readability
  theme(
    axis.text.x = element_text(hjust = 1),  # Rotate x-axis labels for better readability
    panel.grid.major = element_line(size = 0.5, color = "grey"),  # Customize gridlines
    panel.grid.minor = element_blank()  # Remove minor gridlines for a cleaner look
  )

range_from<-as.Date(US_MARKET_EQUITY_RETURNS$year)
ggplotly(ggg, dynamicTicks = TRUE) |>
  layout(
    xaxis = list(rangeslider = list(borderwidth = 1)),  # Add range slider to x-axis
    hovermode = "x",
    yaxis = list(value = ".2f") ) # Format ticks as percentage
         
```

```{r}
#| warning: false
#| message: false
# Calculate the correlation matrix
correlation_matrix <- all.data %>%
  select(-month) %>%
  cor(use = "complete.obs")

# Prepare the data for plotting
correlation_heatmap <- as.data.frame(correlation_matrix) %>%
  rownames_to_column(var = "variable1") %>%
  pivot_longer(cols = -variable1, names_to = "variable2", values_to = "correlation")

# Create the heatmap with values displayed
ggplot(correlation_heatmap, aes(x = variable1, y = variable2, fill = correlation)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(correlation, 3)), color = "black", size = 3) +  # Add correlation values
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
  labs(
    title = "Correlation Heatmap",
    subtitle = "Correlation between key economic indicators",
    x = "Variable", 
    y = "Variable", 
    fill = "Correlation"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid = element_blank()
  )
```
```{r}
calculate_trs <- function(starting_salary, wage_growth_data, inflation_data, years_of_service, retirement_benefit_years) {
  
  salary <- starting_salary
  total_contributions <- 0
  salaries <- numeric(years_of_service)
  
  # Helper function: Calculate biweekly employee contributions
  employee_contribution <- function(salary) {
    emp_rate <- ifelse(salary <= 45000, 0.03, 
                       ifelse(salary <= 55000, 0.035,
                              ifelse(salary <= 75000, 0.045,
                                     ifelse(salary <= 100000, 0.0575, 0.06))))
    return(salary * emp_rate / 26)
  }
  
  # Loop to calculate salary progression and contributions
  for (i in 1:years_of_service) {
    annual_increase <- wage_growth_data$annual_ECI_perct[i] / 100
    cpi_rate <- inflation_data$annual_CPI_perct[i] / 100
    salary <- salary * (1 + annual_increase + cpi_rate)
    salaries[i] <- salary
    
    biweekly_contributions <- employee_contribution(salary)
    total_contributions <- total_contributions + biweekly_contributions * 26
  }
  
  # Print Salary Progression for Debugging
  print("::::Year Salary Progression:::::::")
  print(salaries)
  

  
  # Calculate Final Average Salary (FAS)
  last_3_salaries <- tail(salaries, 3)
  FAS <- ifelse(length(last_3_salaries) < 3, mean(salaries), mean(last_3_salaries))
  
  # Helper function: Calculate retirement benefit
  annual_retirement_benefit <- function(FAS, years_of_service, retirement_benefit_years, inflation_data) {
    if (years_of_service <= 20) {
      benefit <- 0.0167 * FAS * years_of_service
    } else if (years_of_service == 20) {
      benefit <- 0.0175 * FAS * years_of_service
    } else {
      benefit <- (0.35 + 0.02 * (years_of_service - 20)) * FAS
    }
    return(benefit)
  }
    

  
  # Calculate the adjusted retirement benefit
  annual_benefit <- annual_retirement_benefit(FAS, years_of_service, retirement_benefit_years, inflation_data)
  
  # Print results
  cat("\n Years of Service:", years_of_service, "\n")
  cat("Final Average Salary (FAS): $", round(FAS, 2), "\n")
  cat("Total Employee Contributions: $", round(total_contributions, 2), "\n")
  cat("Annual Retirement Benefit for without Adjustment", retirement_benefit_years, "years: $", annual_benefit, "\n")
  cat("Monthly Retirement Benefit for without Adjustment", retirement_benefit_years, "years: $", annual_benefit/12, "\n")
  return(annual_benefit)
}
```

```{r}
#| warning: false
#| message: false
# Example usage:
starting_salary <- 50000

# Compute the annual ECI and CPI
wage_growth_data <- WAGE_GROWTH_GOVT_EMPLOYEES |>
  select(month, wage_growth_rate) |>
  mutate(year = year(month)) |>
  group_by(year) |>
  summarize(annual_ECI = mean(wage_growth_rate, na.rm = TRUE)) |>
  mutate(annual_ECI_perct = ((annual_ECI - lag(annual_ECI)) / lag(annual_ECI)) * 100) |>
  filter(year >= year(min(all.data$month))) |>
  na.omit()

inflation_data <- INFLATION_US_URBAN_AVERAGE |>
  select(month, US_City_Monthly_Inflation_Average) |>
  mutate(year = year(month)) |>
  group_by(year) |>
  summarize(annual_CPI = mean(US_City_Monthly_Inflation_Average, na.rm = TRUE)) |>
  mutate(annual_CPI_perct = ((annual_CPI - lag(annual_CPI)) / lag(annual_CPI)) * 100) |>
  filter(year >= year(min(all.data$month))) |>
  na.omit()

# Calculate years of service
years_of_service <- as.integer(difftime(max(all.data$month), min(all.data$month), units = "days") / 365.25)
retirement_benefit_years <- 15
# Test the function
annual_benefit=calculate_trs(starting_salary, wage_growth_data, inflation_data, years_of_service, retirement_benefit_years)
```

```{r}
#| warning: false
#| message: false
# Adjust benefit for inflation during retirement
    for (year in 1:retirement_benefit_years) {
      if (year > nrow(inflation_data)) break
      cpi_adjustment <- inflation_data$annual_CPI_perct[year] / 100
      annual_benefit <- annual_benefit * (1 + cpi_adjustment)
      cat("Inflation Adjusted Annual Benefits for Year",year,":","$",annual_benefit,"\t Monthly Benefits:","$",annual_benefit/12,"\n")
    }
    
```
```{r}
#| warning: false
#| message: false
# Define a function to calculate the asset allocation based on age
calculate_allocation <- function(age) {
  
  # Default asset allocation for all categories
  stocks1_optperc <- 0.27 / 0.55 * 0.7
  stocks2_optperc <- 0.14 / 0.55 * 0.7
  stocks3_optperc <- 0.14 / 0.55 * 0.7
  stocks_optperc <- stocks1_optperc + stocks2_optperc + stocks3_optperc
  
  international1_optperc <- 0.075 / 0.275 * 0.15
  international2_optperc <- 0.075 / 0.275 * 0.15
  international3_optperc <- 0.125 / 0.275 * 0.15
  international_optperc <- international1_optperc + international2_optperc + international3_optperc
  
  bond_optperc <-0
  shortterm_optperc <-0
  
  # Total allocation
  total_optperc <- stocks_optperc + international_optperc + bond_optperc + shortterm_optperc
  
  # Determine asset allocation based on age
  if (age >= 25 & age <= 49) {
    # Age 25-49: 54% US Equities, 36% International Equities, 10% Bonds
    stocks_optperc <- 0.54
    international_optperc <- 0.36
    bond_optperc <- 0.10
    
      
  } else if (age >= 50 & age <= 59) {
    # Age 50-59: 47% US Equities, 32% International Equities, 21% Bonds
    stocks_optperc <- 0.47
    international_optperc <- 0.32
    bond_optperc <- 0.21
   
  } else if (age >= 60 & age <= 74) {
    # Age 60-74: 34% US Equities, 23% International Equities, 43% Bonds
    stocks_optperc <- 0.34
    international_optperc <- 0.23
    bond_optperc <- 0.43
    
  } else if (age >= 75) {
    # Age 75 and older: 19% US Equities, 13% International Equities, 62% Bonds, 6% Short-Term Debt
    stocks_optperc <- 0.19
    international_optperc <- 0.13
    bond_optperc <- 0.62
    shortterm_optperc <- 0.06
  }
  
  # Calculate total allocation for the specified age range
  total_optperc <- stocks_optperc + international_optperc + bond_optperc + shortterm_optperc
  
  # Return the calculated allocation as a list
  allocation <- list(
    stocks = stocks_optperc,
    international = international_optperc,
    bonds = bond_optperc,
    short_term = shortterm_optperc,
    total = total_optperc
  )
  
  return(allocation)
}
```

```{r}

#| warning: false
#| message: false

# Asset returns (annual average return in % for stocks, international, bonds, short term)
asset_returns <- c(stocks = all.data$US_equity_market_return, international = all.data$Int_equity_market_return, bonds = all.data$Bonds_equity_market_return, short_term = all.data$`VSGDX_returns(%)`)
calculate_orp_with_age <- function(starting_salary, starting_age, wage_growth_data, 
                                   inflation_data, years_of_service, asset_returns) {
  
  salary <- starting_salary
  total_balance <- 0
  current_age <- starting_age
  
  # Check for NA values in wage_growth_data and inflation_data
  if (any(is.na(wage_growth_data$annual_ECI_perct))) {
    warning("Wage growth data contains NA values. Please check the data.")
  }
  if (any(is.na(inflation_data$annual_CPI_perct))) {
    warning("Inflation data contains NA values. Please check the data.")
  }
  
  # Helper function: Calculate employee contribution rate
  employee_contribution_rate <- function(salary) {
    if (is.na(salary)) {
      stop("Salary is NA. Please provide a valid salary.")  # Stop execution if salary is NA
    }
    if (salary <= 45000) return(0.03)
    else if (salary <= 55000) return(0.035)
    else if (salary <= 75000) return(0.045)
    else if (salary <= 100000) return(0.0575)
    else return(0.06)
  }
  
  # Loop through each year of service
  for (i in 1:years_of_service) {
    # Ensure wage_growth_data and inflation_data have valid entries
    if (i <= nrow(wage_growth_data)) {
      annual_increase <- wage_growth_data$annual_ECI_perct[i] / 100
    } else {
      annual_increase <- 0
    }
    
    if (i <= nrow(inflation_data)) {
      cpi_rate <- inflation_data$annual_CPI_perct[i] / 100
    } else {
      cpi_rate <- 0
    }
    
    # Update salary considering wage growth and inflation
    salary <- salary * (1 + annual_increase + cpi_rate)
    
    # Validate salary before calculating contributions
    if (is.na(salary) || salary <= 0) {
      stop("Salary is invalid or less than zero after adjustments. Please check the data.")
    }
    
    emp_rate <- employee_contribution_rate(salary)
    emp_contrib <- emp_rate * salary
    emp_monthly <- emp_contrib / 12
    
    employer_rate <- ifelse(i <= 7, 0.08, 0.10)
    employer_contrib <- employer_rate * salary
    employer_monthly <- employer_contrib / 12
    
    monthly_contrib <- emp_monthly + employer_monthly
    
    # Get the asset allocation based on the current age
    allocation <- calculate_allocation(current_age)
    
    # Annual growth of the portfolio based on asset returns and allocation
    annual_growth_rate <- sum(c(allocation$stocks, allocation$international/100, 
                                allocation$bonds/100, allocation$short_term/100) * asset_returns) / 100
    total_balance <- (total_balance + monthly_contrib * 12) * (1 + annual_growth_rate)
    
    current_age <- current_age + 1  # Increment age by 1 year
  }
  
  # Calculate 4% withdrawal strategy
  annual_payout <- total_balance * 0.04
  monthly_payout <- annual_payout / 12
  
  # Return total balance at retirement and the payouts
  result <- list(
    total_balance = total_balance,
    annual_payout = annual_payout,
    monthly_payout = monthly_payout
  )
  
  return(result)
}

 #Test the function with valid data
starting_salary <- 50000
starting_age <- 50
years_of_service <- 15
#annual.return=all.data|>select(US_equity_market_return,month)|>group_by(year(month))|>


result <- calculate_orp_with_age(starting_salary, starting_age, wage_growth_data, 
                                 inflation_data, years_of_service, asset_returns)

# Print results
cat("Total fund at retirement: $", round(result$total_balance, 2), "\n")
cat("Annual payout (4% withdrawal): $", round(result$annual_payout, 2), "\n")
cat("Monthly payout: $", round(result$monthly_payout, 2), "\n")
```



